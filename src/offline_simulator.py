#!/usr/bin/env python3
"""
オフライン AI シミュレーター
APIキーがない場合の疑似AI応答を提供
"""

import random
import time
from typing import Dict, List, Any

class OfflineAISimulator:
    """APIキーなしでもデモ動作するAIシミュレーター"""
    
    def __init__(self):
        self.chatgpt_templates = [
            "プロジェクト「{request}」について分析します。",
            "要件を整理すると、以下の機能が必要です：",
            "このプロジェクトの技術スタックとして推奨するのは：",
            "実装において重要なポイントは：",
        ]
        
        self.claude_templates = [
            "ChatGPTの提案を受けて、実装を開始します。",
            "以下のコードを生成しました：",
            "エラーハンドリングとテストも含めて実装します。",
            "最適化とリファクタリングを行いました。",
        ]
        
        self.gemini_templates = [
            "高速処理のために最適化を実行します。",
            "パフォーマンス改善とスケーラビリティを検討しました。",
            "追加機能として以下を提案します：",
            "総合的な品質チェックを実行しました。",
        ]
        
        self.code_examples = {
            "python": """
# Python Example Code
def main():
    print("Hello, World from AI Collaboration!")
    return True

if __name__ == "__main__":
    main()
""",
            "javascript": """
// JavaScript Example Code
function collaborationDemo() {
    console.log("AI Collaboration System Demo");
    return {
        status: "success",
        message: "Generated by offline simulator"
    };
}

collaborationDemo();
""",
            "html": """
<!DOCTYPE html>
<html>
<head>
    <title>AI Collaboration Demo</title>
</head>
<body>
    <h1>Generated by AI Collaboration System</h1>
    <p>This is a demo output from the offline simulator.</p>
</body>
</html>
"""
        }
    
    def simulate_chatgpt_response(self, request: str, mode: str = "all") -> Dict[str, Any]:
        """ChatGPT の疑似応答を生成"""
        if mode in ["claude-only", "gemini-only", "offline"]:
            return {"skip": True}
            
        time.sleep(random.uniform(1, 3))  # リアルな遅延をシミュレート
        
        template = random.choice(self.chatgpt_templates)
        response = template.format(request=request)
        
        if "分析" in template:
            response += f"""

【プロジェクト分析結果】
- プロジェクト名: {request}
- 推定工数: 2-3週間
- 必要技術: Python, HTML/CSS, JavaScript
- 優先度: 高

【推奨実装方針】
1. MVPから開始
2. ユーザビリティを重視
3. セキュリティを考慮した設計
4. テスト駆動開発

次はClaudeが具体的な実装を行います。
"""
        
        return {
            "speaker": "chatgpt",
            "message": response,
            "timestamp": time.time(),
            "simulated": True
        }
    
    def simulate_claude_response(self, request: str, mode: str = "all") -> Dict[str, Any]:
        """Claude の疑似応答を生成"""
        if mode in ["gpt-only", "gemini-only", "offline"]:
            return {"skip": True}
            
        time.sleep(random.uniform(2, 4))  # リアルな遅延をシミュレート
        
        template = random.choice(self.claude_templates)
        response = template.format(request=request)
        
        # コード例を追加
        lang = random.choice(list(self.code_examples.keys()))
        code = self.code_examples[lang]
        
        response += f"""

【実装コード例】
```{lang}
{code.strip()}
```

【実装のポイント】
- エラーハンドリングを含む堅牢な設計
- 可読性とメンテナンス性を重視
- パフォーマンス最適化を考慮
- セキュリティベストプラクティスに準拠

次はGeminiが最適化と追加機能を検討します。
"""
        
        return {
            "speaker": "claude",
            "message": response,
            "timestamp": time.time(),
            "simulated": True
        }
    
    def simulate_gemini_response(self, request: str, mode: str = "all") -> Dict[str, Any]:
        """Gemini の疑似応答を生成"""
        if mode in ["gpt-only", "claude-only", "offline"]:
            return {"skip": True}
            
        time.sleep(random.uniform(1, 2))  # 高速処理をシミュレート
        
        template = random.choice(self.gemini_templates)
        response = template.format(request=request)
        
        response += f"""

【最適化結果】
- パフォーマンス: 85% 改善
- メモリ使用量: 40% 削減
- レスポンス時間: 200ms 短縮

【追加提案機能】
1. リアルタイム更新機能
2. データ可視化ダッシュボード
3. モバイル対応
4. API統合機能

【品質チェック】
✅ コード品質: 優秀
✅ セキュリティ: 問題なし
✅ パフォーマンス: 最適化済み
✅ 拡張性: 良好

プロジェクト「{request}」の実装が完了しました！
"""
        
        return {
            "speaker": "gemini",
            "message": response,
            "timestamp": time.time(),
            "simulated": True
        }
    
    def simulate_offline_response(self, request: str) -> Dict[str, Any]:
        """完全オフライン用の応答"""
        time.sleep(random.uniform(0.5, 1.5))
        
        response = f"""
【オフラインシミュレーションモード】

プロジェクト「{request}」について、以下のような実装が考えられます：

【基本構成】
- フロントエンド: HTML/CSS/JavaScript
- バックエンド: Python Flask/FastAPI
- データベース: SQLite または PostgreSQL

【推奨ファイル構造】
```
project/
├── app.py              # メインアプリケーション
├── templates/          # HTMLテンプレート
├── static/            # CSS/JavaScript
├── models/            # データモデル
├── tests/             # テストファイル
└── requirements.txt   # 依存関係
```

【実装例（Python）】
```python
from flask import Flask, render_template, request

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/demo')
def demo_api():
    return {{"status": "success", "message": "Demo API"}}

if __name__ == '__main__':
    app.run(debug=True)
```

【次のステップ】
1. 詳細要件の確認
2. データベース設計
3. API設計
4. UI/UXデザイン

APIキーを設定すると、実際のAIとの協調開発が可能になります。
- OpenAI API Key (ChatGPT用)
- Anthropic API Key (Claude用)  
- Google AI Studio API Key (Gemini用)

このシミュレーションモードでは基本的な開発ガイダンスを提供します。
"""
        
        return {
            "speaker": "offline",
            "message": response,
            "timestamp": time.time(),
            "simulated": True
        }
    
    def simulate_conversation(self, request: str, mode: str = "all") -> List[Dict[str, Any]]:
        """完全な協調会話をシミュレート"""
        responses = []
        
        if mode == "offline":
            responses.append(self.simulate_offline_response(request))
        elif mode == "gpt-only":
            responses.append(self.simulate_chatgpt_response(request, mode))
        elif mode == "claude-only":
            responses.append(self.simulate_claude_response(request, mode))
        elif mode == "gemini-only":
            responses.append(self.simulate_gemini_response(request, mode))
        else:  # all mode
            # ChatGPT -> Claude -> Gemini の順序で実行
            gpt_response = self.simulate_chatgpt_response(request, mode)
            if not gpt_response.get("skip"):
                responses.append(gpt_response)
            
            claude_response = self.simulate_claude_response(request, mode)
            if not claude_response.get("skip"):
                responses.append(claude_response)
            
            gemini_response = self.simulate_gemini_response(request, mode)
            if not gemini_response.get("skip"):
                responses.append(gemini_response)
        
        return responses